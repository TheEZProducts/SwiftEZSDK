//
//  File.swift
//  
//
//  Created by Александр Сенин on 30.05.2023.
//

import Foundation
import RegexBuilder

struct FileModel{
    var name: String = ""
    var keys: [String] = []
    var fullNames: [String] = []
    var instanceNames: [String] = []
    
    func removeDuplicate() -> Self{
        var new = self
        new.keys = keys.removeDuplicate()
        new.fullNames = fullNames.removeDuplicate()
        new.instanceNames = instanceNames.removeDuplicate()
        return new
    }
}

extension Array where Element == FileModel{
    func mergeDuplicate() -> Self{
        var dic = [String: Int]()
        var new = Self()
        forEach{
            if let key = dic[$0.name] {
                new[key].keys += $0.keys
                new[key].fullNames += $0.fullNames
                new[key].instanceNames += $0.instanceNames
            }else{
                dic[$0.name] = new.count
                new.append($0)
            }
        }
        
        return new.map { $0.removeDuplicate() }
    }
}

@main
@available(macOS 13.0, watchOS 6.0, tvOS 13.0, iOS 16.0, *)
struct EZJsonKeysGenerator {
    static func main() async throws {
        let output = URL(fileURLWithPath: CommandLine.arguments[1])
        let sourceFiles = CommandLine.arguments.dropFirst(2)
        
        let models = sourceFiles.compactMap {value in
            if let (name, instanceName, fullName) = getName(jsonPath: value), let json = pars(jsonPath: value){
                return FileModel(name: name, keys: getKeys(json: json), fullNames: [fullName], instanceNames: [instanceName])
            }else{
                return nil
            }
        }.mergeDuplicate()

        let enums = models.map{ model in
            let cases = model.keys.map { key in caseTemplate(makePrety(text: key), key) }.joined(separator: "\n")
            let jsons = model.fullNames.enumerated().map{value in
                jsonTemplate(makePrety(text: model.instanceNames[value.offset]), value.element)
            }.joined(separator: "\n\n")
            return enumTemplate(model.name, cases, jsons)
        }.joined(separator: "\n\n\n")
        let file = fileTemplate(enums, sourceFiles.map{ pathTemplate($0) }.joined(separator: "\n"))
        
        guard let fileData = file.data(using: .utf8) else {return}
        try fileData.write(to: output, options: .atomic)
    }
    
    private static func remove(at url: URL){
        if FileManager().fileExists(atPath: url.path){
            try? FileManager.default.removeItem(at: url)
        }
    }
    
    private static func pars(jsonPath: String) -> Any?{
        let url = URL(fileURLWithPath: jsonPath)
        guard
            let data = try? Data(contentsOf: url),
            let json = try? JSONSerialization.jsonObject(with: data)
        else {return nil}
        return json
    }
    
    private static func getKeys(json: Any) -> [String]{
        switch json{
        case let value as [Any]: return value.flatMap{ getKeys(json: $0) }
        case let value as [String: Any]: return value.flatMap{ [$0.key] + getKeys(json: $0.value) }
        default: break
        }
        return []
    }
    
    private static func getName(jsonPath: String) -> (String, String, String)?{
        let url = URL(fileURLWithPath: jsonPath)
        let path = url.lastPathComponent.replacingOccurrences(of: ".ez.json", with: "").components(separatedBy: "-")
        
        let instanceName = [String](path.dropFirst()).joined()
        if let name = path.first, name != "", instanceName != ""{
            return (name, instanceName, url.lastPathComponent)
        }
        return nil
    }
    
    private static var fileTemplate = {
        """
        //
        // EZJsonKeysPlugin.generated.swift
        //
        // Generated by EZJsonKeysPlugin on \(Date())
        // From paths:
        ${1}
        //
        
        import Foundation
        #if canImport(EZJsonStriderKit)
        import EZJsonStriderKit
        #endif
        
        ${0}
        """
    }()
    
    private static var enumTemplate = {
        """
        //MARK: - ${0}
        enum ${0}Key: String, CaseIterable{
        ${1}
        }
        #if canImport(EZJsonStriderKit)
        typealias ${0}Strider = EZJsonStrider<${0}Key>
        extension ${0}Strider{
        ${2}
        }
        extension ${0}Key: EZJsonKeyProtocol{}
        #endif
        """
    }()
    
    private static var pathTemplate = {
        """
        // ${0}
        """
    }()
    
    private static var jsonTemplate = {
        """
        \t//MARK: ${1}
        \tstatic var ${0}FileName: String { \"${1}\" }
        \tstatic var ${0}: Self { .init(name: ${0}FileName) }
        """
    }()
    
    private static var caseTemplate = {
        """
        \tcase `${0}` = \"${1}\"; var `${0}`: Self {.`${0}`}
        """
    }()
    
    private static func makePrety(text: String) -> String{
        let words = text
            .replacing(
                Regex { CharacterClass(.anyOf("-./()"), .whitespace) },
                with: "_"
            )
            .components(separatedBy: "_")
        var first = true
        var result = ""
        for word in words{
            if first{
                first = false
                result += word.firstLowercased
            }else{
                result += word.firstUppercased
            }
        }
        return result
    }
}

extension Array where Element: Hashable{
    func removeDuplicate() -> Self{
        var set = Set<Element>()
        return filter {
            if set.contains($0) { return false }
            set.insert($0)
            return true
        }
    }
}


extension String{
    func addValues(_ values: [String: String]) -> String{
        var text = self
        for (key, value) in values{
            text = text.replacingOccurrences(of: "${\(key)}", with: "\(value)")
        }
        return text
    }
    
    @_disfavoredOverload
    func addValues(_ values: Any...) -> String{
        var text = self
        for (i, value) in values.enumerated(){
            text = text.replacingOccurrences(of: "${\(i)}", with: "\(value)")
        }
        return text
    }
    
    func callAsFunction(_ values: Any...) -> String {
        self.addValues(values)
    }
       
    var firstLowercased: String {
        return prefix(1).lowercased() + dropFirst()
    }
    var firstUppercased: String {
        return prefix(1).uppercased() + dropFirst()
    }
}
